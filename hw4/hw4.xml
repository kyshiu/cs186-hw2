<?xml version="1.0" encoding="UTF-8"?>
<!--
UC Berkeley CS186 Database course
Assignment 4

Put your answers in blocks wrapped by "<![CDATA[" and "]]>". Each block is
marked with TODO. Remove the TODO after putting your answer in.

If the "autograde" attribute is "yes" for a question, the question will be
marked using a grading script. Make sure you follow the instructions on the
format for the answers.
-->
<assignment>

<!--
Question 1 SOME EASY STUFF

Connect to the database.  Type "\d" to see the list of relations in the
database.  Use SQL queries to examine these relations. In particular examine
the relation Rankings. Answer the following questions:
-->
<question id="1a" autograde="yes"
  text="What are the attributes of the Students relation?">
<![CDATA[
id, name, school
]]></question>

<question id="1b1" autograde="yes"
  text="How many indexes are built on the Rankings relation?">
<![CDATA[
2
]]></question>

<question id="1b2" autograde="yes"
  text="Name the indexes and write down their type?">
<![CDATA[
rankings_pkey, btree
gradrate_idx, btree
]]></question>

<question id="1c" autograde="yes"
  text="How many tuples are there in the Rankings relation?">
<![CDATA[
1302
]]></question>

<question id="1d" autograde="yes"
  text="How many distinct values of state does the query planner estimate there
       are for the Rankings relation?
       (hint: Query pg_stats to find out)">
<![CDATA[
51
]]></question>

<question id="1e" autograde="yes"
  text="How many distinct values of state are there actually in the rankings
        table? (hint: it's probably easiest to run a query to compute
        this!)">
<![CDATA[
51
]]></question>

<question id="1f"
  text="What query did you use to find the answer to E?">
<![CDATA[
SELECT COUNT(DISTINCT state) FROM rankings;
]]></question>
	
<!--
Question 2 USING THE QUERY PLAN VIEWER

This question requires you to use the PostgreSQL query plan visualization
command EXPLAIN. Read the documentation for EXPLAIN at the link given above.
Note that (like System R) EXPLAIN estimates query costs in units of disk I/Os
(CPU instructions are added in by multiplying times a conversion factor).
Consider the following query:

SELECT * FROM rankings WHERE state = 'CA'; 

Answer the following questions looking at the query plan generated by the
EXPLAIN command:
-->
<question id="2a"
  text="Briefly describe the plan chosen.">
<![CDATA[
A sequential scan will be used on the table.
]]></question>

<question id="2b"
  text="In what order would the tuples be returned by this plan? Why?">
<![CDATA[
Tuples will be returned in the order they appear in the table because sequential scan begins scanning from the front of the table and makes its way to the end.
]]></question>

<question id="2c" autograde="yes"
  text="What is the estimated total cost of running the plan?">
<![CDATA[
48.27
]]></question>

<question id="2d"
  text="What is the estimated result cardinality for this plan? Looking at the
        statistics, why does the optimizer come up with this estimate?">
<![CDATA[
70 rows.  'pg_stats' reveals the estimated frequency of CA to be 0.0537.  This is multiplied by the total number of rows in 'rankings' to derive the answer.
]]></question>

<question id="2e" autograde="yes"
  text="How many colleges actually do have state = 'CA'?">
<![CDATA[
70
]]></question>

<question id="2f"
  text="Looking at the statistics, what are the top 5 states with the most
        colleges and the percentage of colleges in each of those state?">
<![CDATA[
NY, 7.76%
PA, 6.37%
CA, 5.38%
TX, 4.61%
MA, 4.30%
]]></question>

<question id="2g"
  text="Which value of state is actually the most popular, and how many tuples
        have that state? How did you figure this out (what query did you use)?">
<![CDATA[
NY is most popular with 101 tuples. SELECT state, COUNT(id) AS count FROM rankings GROUP BY state ORDER BY count DESC;
]]></question>

<!--
Question 3 SELECTS WITH INDEXES

Consider the same query from previous question: 

SELECT * FROM rankings WHERE state = 'CA'; 

Answer the following questions looking at the plans and the access methods:
-->
<question id="3a"
  text="Create a btree index on the attribute state of the relation Rankings.
        What is the plan chosen for the query now?">
<![CDATA[
Bitmap Heap Scan on rankings, Bitmap Index Scan on state index.
]]></question>

<question id="3b" autograde="yes"
  text="What is the estimated total cost of running the plan?">
<![CDATA[
37.67
]]></question>

<question id="3c"
  text="Compare this plan with the plan obtained in question 2.A above.
        Which is cheaper and why?">
<![CDATA[
The total cost is cheaper than sequential scan, but the time to cost to find the first tuple is longer (but we don't really care about this for this query anyways).  Our new plan is cheaper because it can now use the index to try and grab only the tuples it needs.  
]]></question>

<!--
Question 4 RANGE SELECTS

DROP the index that you created for Question 3. Don't forget to VACUUM ANALYZE
Now analyze the query plan that PostgreSQL comes up for the following query: 

SELECT * FROM rankings WHERE gradrate < 10;

Answer the following questions:
-->
<question id="4a" autograde="yes"
  text="How many ranking tuples that have gradrate &lt; 10 does the
        optimizer think there are?">
<![CDATA[
2
]]></question>

<question id="4b"
  text="In what order will the tuples be returned by this plan?">
<![CDATA[
They will return in the order in which they are indexed.
]]></question>

<question id="4c"
  text="What is a value of the constant (i.e. '10' in the above query) such
        that the optimizer chooses a different plan? What is that plan and why
        does the optimizer think it will be cheaper than the previous plan when
        used with this new constant?">
<![CDATA[
The optimizer chooses to use sequential scan if the constant is 100.  If the optimizer estimates that a majority of the tuples will be selected from the table, then scanning through everything will be more efficient than dealing with the overhead of using indexes.
]]></question>

<!--
Question 5 SIMPLE JOIN

Create a B-tree index on 'studentfacultyratio' of the rankings table.
Analyze the query plan for the following query that finds the average salary at
schools who have a student to faculty ratio < 5.

SELECT R.name, F.avesalary 
FROM rankings R, financials F
WHERE R.id = F.id AND R.studentfacultyratio < 5; 

Answer the following questions:
-->
<question id="5a"
  text="What is the estimated cost of this plan?">
<![CDATA[
32.60
]]></question>

<question id="5b" autograde="yes"
  text="What kind of join is used by the plan?">
<![CDATA[
Hash Join
]]></question>

<question id="5c1" autograde="yes"
  text="Disable the join type used in the above plan and re-optimize the query.
        What type of join is used now?">
<![CDATA[
Nested Loop
]]></question>

<question id="5c2" autograde="yes"
  text="And what is the total estimated cost of the query?">
<![CDATA[
78.95
]]></question>

<!--
Question 6 THREE-WAY JOIN

DROP the index that you created for Question 5, RE-ENABLE (using "SET") the join method you turned off above, Don't forget to VACUUM ANALYZE
Answer the following questions referring to the query below: 

SELECT S.name, R.name, F.avesalary
FROM students S, rankings R, financials F
WHERE S.school = R.id and R.id = F.id;
-->
<question id="6a"
  text="Describe the best plan estimated by the optimizer. List the joins and
        access methods it uses, and the order in which the relations are
        joined.">
<![CDATA[
First it hash joins financials and students and then it hash joins that result to rankings.  All access is done by sequential scan.
]]></question>

<question id="6b"
  text="Modify the query by adding a condition R.studentfacultyratio &lt; 8.
        What is the relational algebra expression for the new join order?
        Why is this new join ordering better for the extended query than the
        ordering obtained in part A?">
<![CDATA[
students Join_[s.school=r.id](financials Join_[f.id=r.id](Select_[studentfacultyratio<8] (rankings)))
With this join order, some tuples can be removed from rankings right at the start to eliminate wasteful reading of tuples that won't be returned in the end.
]]></question>

<!--
Question 7 SQL

Answer the following questions about the database (by writing queries!):
-->
<question id="7a" autograde="yes"
  text="What is the name of the public school (public = 1) with the highest
        average salary?">
<![CDATA[
Rutgers State University at Newark 
]]></question>

<question id="7b" autograde="yes"
  text="Find the public school (public = 1) with the largest difference
        between instate tuition and out of state tuition that has at least
        one student attending.">
<![CDATA[
Albany State College
]]></question>

</assignment>
